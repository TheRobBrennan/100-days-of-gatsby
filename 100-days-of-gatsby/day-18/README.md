# Day 18 - Saturday, January 18th, 2020

Today's focus is on [Images, Files & Video in Gatsby](https://www.gatsbyjs.org/docs/images-and-files/)

## Scratchpad

To create a new Gatsby app, I will use `npx` to create a new [Gatsby](https://www.gatsbyjs.com) app using the latest version of the [Gatsby CLI](https://www.gatsbyjs.com):

```sh
# Generate a new app using the latest version of the Gatsby CLI
$ npx gatsby new app
  # OPTIONAL: Copy the Dockerized Gatsby CLI example to an appropriate folder for a faster starting point
  $ cp -r 100-days-of-gatsby/default-gatsby-cli-app-dockerized 100-days-of-gatsby/day-##

# Navigate to the appropriate example directory
$ cd 100-days-of-gatsby/day-##

# Navigate to the app directory
$ cd app
```

## Images, Files & Video in Gatsby

Gatsby provides multiple solutions for adding images, video, and files to your projects. And a pro tip: you don’t necessarily have to use GraphQL! From [imports](https://www.gatsbyjs.org/docs/importing-assets-into-files/) and use of the [static folder](https://www.gatsbyjs.org/docs/static-folder/) to dynamic queries with [Gatsby Image](https://www.gatsbyjs.org/docs/using-gatsby-image/) to prevent image bloat, you’ve got options.

This section will walk you through several common patterns for handling media with Gatsby, where you can learn about the pros and cons of each method.

### Importing Assets Directly into Files

#### Importing assets with Webpack

With Webpack you can import a file right in a JavaScript module. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This imported file’s value is the final path you can reference in your code, e.g. as the src attribute of an image or the href of a link to a PDF.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: svg, jpg, jpeg, png, gif, mp4, webm, wav, mp3, m4a, aac, and oga.

Here’s an example:

```jsx
import React from "react"
import logo from "./logo.png" // Tell Webpack this JS file uses this image

console.log(logo) // /logo.84287d09.png

function Header() {
  // Import result is the URL of your image
  return <img src={logo} alt="Logo" />
}

export default Header
```

This ensures that when the project is built, Webpack will correctly move the images into the public folder, and provide us with correct paths.

You can reference files in CSS to import them, too:

```css
.Logo {
  background-image: url(./logo.png);
}
```

Webpack finds all relative module references in CSS (they start with ./) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets.

If you’re using SCSS the imports are relative to the entry SCSS file.

Please be advised that this is also a custom feature of Webpack.

#### Querying for a File in GraphQL using gatsby-source-filesystem

You can also import files using GraphQL by querying for them in your data layer, which will trigger copying of those files to the public directory. Querying for the `publicURL` field of `File` nodes will provide URLs you can use in your JavaScript components, pages and templates.

##### Example: Copy all .pdf files you have in your data layer to your build directory and return URLs to them:

```graphql
{
  allFile(filter: { extension: { eq: "pdf" } }) {
    edges {
      node {
        publicURL
      }
    }
  }
}
```

Reference those PDF files in a page with useStaticQuery:

```jsx
import React from "react"
import { useStaticQuery, graphql } from "gatsby"

import Layout from "../components/layout"

const DownloadsPage = () => {
  const data = useStaticQuery(graphql`
    {
      allFile(filter: { extension: { eq: "pdf" } }) {
        edges {
          node {
            publicURL
            name
          }
        }
      }
    }
  `)
  return (
    <Layout>
      <h1>All PDF Downloads</h1>
      <ul>
        {data.allFile.edges.map((file, index) => {
          return (
            <li key={`pdf-${index}`}>
              <a href={file.node.publicURL} download>
                {file.node.name}
              </a>
            </li>
          )
        })}
      </ul>
    </Layout>
  )
}
export default DownloadsPage
```

##### Example: Link to attachments in the frontmatter of your Markdown files:

```md
---
title: "Title of article"
attachments:
  - "./assets.zip"
  - "./presentation.pdf"
---

Hi, this is a great article.
```

In an article template component file, you can then query for the attachments:

```graphql
query($slug: String!) {
  markdownRemark(fields: { slug: { eq: $slug } }) {
    html
    frontmatter {
      title
      attachments {
        publicURL
      }
    }
  }
}
```

### Using the Static Folder

In general, every website needs assets: images, stylesheets, scripts, etc. When using Gatsby, we recommend Importing Assets Directly in JavaScript files, because of the benefits it provides:

+ Scripts and stylesheets are minified and bundled together to avoid extra network requests.
+ Missing files cause compilation errors instead of 404 errors for your users.
+ Result filenames include content hashes so you don’t need to worry about browsers caching their old versions.

However, there is an escape hatch that you can use to add an asset outside of the module system.

#### Adding assets outside of the module system

You can create a folder named static at the root of your project. Every file you put into that folder will be copied into the public folder. E.g. if you add a file named `sun.jpg` to the static folder, it’ll be copied to `public/sun.jpg`

##### Referencing your static asset

You can reference assets from the static folder in your code without anything special required:

```jsx
render() {
  // Note: this is an escape hatch and should be used sparingly!
  // Normally we recommend using `import` for getting asset URLs
  // as described in the “Importing Assets Directly Into Files” page.
  return <img src={'/logo.png'} alt="Logo" />;
}
```

##### Downsides

Keep in mind the downsides of this approach:

+ None of the files in the `static` folder will be post-processed or minified.
+ Missing files will not be called at compilation time, and will cause 404 errors for your users.
+ Result filenames won’t include content hashes, so you’ll need to add query arguments or rename them every time they change.

#### When to use the static folder

Normally we recommend importing stylesheets, images, and font assets from JavaScript. The static folder is useful as a workaround for a number of less common cases:

+ You need a file with a specific name in the build output, such as manifest.webmanifest.
+ You have thousands of images and need to dynamically reference their paths.
+ You want to include a small script like pace.js outside of the bundled code.
+ Some libraries may be incompatible with Webpack and you have no other option but to include it as a <script> tag.
+ You need to import JSON file that doesn’t have a consistent schema, like TopoJSON files, which is difficult to handle with GraphQL. Note that importing JSON files directly inside a page, a template, or a component using import syntax results in adding that file to the app bundle and increasing the size of all site’s pages. Instead, it’s better to place your JSON file inside the static folder and use the dynamic import syntax (import('/static/myjson.json')) within the componentDidMount lifecycle or the useEffect hook.

### Using gatsby-image

### Working with Images in Gatsby

### Preoptimizing Your Images

### Working with Video

### Importing Media Content

### Working with GIFs

### Working with Images in Markdown

### Preprocessing External Images
