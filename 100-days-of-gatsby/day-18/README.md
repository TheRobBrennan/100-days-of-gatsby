# Day 18 - Saturday, January 18th, 2020

Today's focus is on [Images, Files & Video in Gatsby](https://www.gatsbyjs.org/docs/images-and-files/)

## Scratchpad

To create a new Gatsby app, I will use `npx` to create a new [Gatsby](https://www.gatsbyjs.com) app using the latest version of the [Gatsby CLI](https://www.gatsbyjs.com):

```sh
# Generate a new app using the latest version of the Gatsby CLI
$ npx gatsby new app
  # OPTIONAL: Copy the Dockerized Gatsby CLI example to an appropriate folder for a faster starting point
  $ cp -r 100-days-of-gatsby/default-gatsby-cli-app-dockerized 100-days-of-gatsby/day-##

# Navigate to the appropriate example directory
$ cd 100-days-of-gatsby/day-##

# Navigate to the app directory
$ cd app
```

## Images, Files & Video in Gatsby

Gatsby provides multiple solutions for adding images, video, and files to your projects. And a pro tip: you don’t necessarily have to use GraphQL! From [imports](https://www.gatsbyjs.org/docs/importing-assets-into-files/) and use of the [static folder](https://www.gatsbyjs.org/docs/static-folder/) to dynamic queries with [Gatsby Image](https://www.gatsbyjs.org/docs/using-gatsby-image/) to prevent image bloat, you’ve got options.

This section will walk you through several common patterns for handling media with Gatsby, where you can learn about the pros and cons of each method.

### Importing Assets Directly into Files

#### Importing assets with Webpack

With Webpack you can import a file right in a JavaScript module. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This imported file’s value is the final path you can reference in your code, e.g. as the src attribute of an image or the href of a link to a PDF.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: svg, jpg, jpeg, png, gif, mp4, webm, wav, mp3, m4a, aac, and oga.

Here’s an example:

```jsx
import React from "react"
import logo from "./logo.png" // Tell Webpack this JS file uses this image

console.log(logo) // /logo.84287d09.png

function Header() {
  // Import result is the URL of your image
  return <img src={logo} alt="Logo" />
}

export default Header
```

This ensures that when the project is built, Webpack will correctly move the images into the public folder, and provide us with correct paths.

You can reference files in CSS to import them, too:

```css
.Logo {
  background-image: url(./logo.png);
}
```

Webpack finds all relative module references in CSS (they start with ./) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets.

If you’re using SCSS the imports are relative to the entry SCSS file.

Please be advised that this is also a custom feature of Webpack.

#### Querying for a File in GraphQL using gatsby-source-filesystem

You can also import files using GraphQL by querying for them in your data layer, which will trigger copying of those files to the public directory. Querying for the `publicURL` field of `File` nodes will provide URLs you can use in your JavaScript components, pages and templates.

##### Example: Copy all .pdf files you have in your data layer to your build directory and return URLs to them:

```graphql
{
  allFile(filter: { extension: { eq: "pdf" } }) {
    edges {
      node {
        publicURL
      }
    }
  }
}
```

Reference those PDF files in a page with useStaticQuery:

```jsx
import React from "react"
import { useStaticQuery, graphql } from "gatsby"

import Layout from "../components/layout"

const DownloadsPage = () => {
  const data = useStaticQuery(graphql`
    {
      allFile(filter: { extension: { eq: "pdf" } }) {
        edges {
          node {
            publicURL
            name
          }
        }
      }
    }
  `)
  return (
    <Layout>
      <h1>All PDF Downloads</h1>
      <ul>
        {data.allFile.edges.map((file, index) => {
          return (
            <li key={`pdf-${index}`}>
              <a href={file.node.publicURL} download>
                {file.node.name}
              </a>
            </li>
          )
        })}
      </ul>
    </Layout>
  )
}
export default DownloadsPage
```

##### Example: Link to attachments in the frontmatter of your Markdown files:

```md
---
title: "Title of article"
attachments:
  - "./assets.zip"
  - "./presentation.pdf"
---

Hi, this is a great article.
```

In an article template component file, you can then query for the attachments:

```graphql
query($slug: String!) {
  markdownRemark(fields: { slug: { eq: $slug } }) {
    html
    frontmatter {
      title
      attachments {
        publicURL
      }
    }
  }
}
```

### Using the Static Folder

In general, every website needs assets: images, stylesheets, scripts, etc. When using Gatsby, we recommend Importing Assets Directly in JavaScript files, because of the benefits it provides:

+ Scripts and stylesheets are minified and bundled together to avoid extra network requests.
+ Missing files cause compilation errors instead of 404 errors for your users.
+ Result filenames include content hashes so you don’t need to worry about browsers caching their old versions.

However, there is an escape hatch that you can use to add an asset outside of the module system.

#### Adding assets outside of the module system

You can create a folder named static at the root of your project. Every file you put into that folder will be copied into the public folder. E.g. if you add a file named `sun.jpg` to the static folder, it’ll be copied to `public/sun.jpg`

##### Referencing your static asset

You can reference assets from the static folder in your code without anything special required:

```jsx
render() {
  // Note: this is an escape hatch and should be used sparingly!
  // Normally we recommend using `import` for getting asset URLs
  // as described in the “Importing Assets Directly Into Files” page.
  return <img src={'/logo.png'} alt="Logo" />;
}
```

##### Downsides

Keep in mind the downsides of this approach:

+ None of the files in the `static` folder will be post-processed or minified.
+ Missing files will not be called at compilation time, and will cause 404 errors for your users.
+ Result filenames won’t include content hashes, so you’ll need to add query arguments or rename them every time they change.

#### When to use the static folder

Normally we recommend importing stylesheets, images, and font assets from JavaScript. The static folder is useful as a workaround for a number of less common cases:

+ You need a file with a specific name in the build output, such as manifest.webmanifest.
+ You have thousands of images and need to dynamically reference their paths.
+ You want to include a small script like pace.js outside of the bundled code.
+ Some libraries may be incompatible with Webpack and you have no other option but to include it as a <script> tag.
+ You need to import JSON file that doesn’t have a consistent schema, like TopoJSON files, which is difficult to handle with GraphQL. Note that importing JSON files directly inside a page, a template, or a component using import syntax results in adding that file to the app bundle and increasing the size of all site’s pages. Instead, it’s better to place your JSON file inside the static folder and use the dynamic import syntax (import('/static/myjson.json')) within the componentDidMount lifecycle or the useEffect hook.

### Using gatsby-image

`gatsby-image` is a React component designed to work seamlessly with Gatsby’s GraphQL queries (gatsby-image plugin README). It combines Gatsby’s native image processing capabilities with advanced image loading techniques to easily and completely optimize image loading for your sites. `gatsby-image` uses `gatsby-plugin-sharp` to power its image transformations.

Warning: `gatsby-image` is not a drop-in replacement for `<img />`. It’s optimized for fixed width/height images and images that stretch the full width of a container. Some ways you can use `<img />` won’t work with `gatsby-image`.

`gatsby-image` includes the tricks you’d expect from a modern image component. It:

+ uses the new [IntersectionObserver API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) to cheaply lazy load images
+ holds an image’s position so your page doesn’t jump around as images load
+ makes it easy to add a placeholder—either a gray background or a blurry version of the image.

For more complete API information, check out the [Gatsby Image API](https://www.gatsbyjs.org/docs/gatsby-image/) docs.

#### Problem

Large, unoptimized images dramatically slow down your site.

But creating optimized images for websites has long been a thorny problem. Ideally, you would:

+ Resize large images to the size needed by your design
+ Generate multiple smaller images so smartphones and tablets don’t download desktop-sized images
+ Strip all unnecessary metadata and optimize JPEG and PNG compression
+ Efficiently lazy load images to speed initial page load and save bandwidth
+ Use the “blur-up” technique or a “traced placeholder” SVG to show a preview of the image while it loads
+ Hold the image position so your page doesn’t jump while the images load
+ Doing this consistently across a site feels like Sisyphean labor. You manually optimize your images and then… several images are swapped in at the last minute or a design-tweak shaves 100px of width off your images.

Most solutions involve a lot of manual labor and bookkeeping to ensure every image is optimized.

This isn’t ideal. Optimized images should be easy and the default.

#### Solution

With Gatsby, you can make the experience of working with images way, way better.

`gatsby-image` is designed to work seamlessly with Gatsby’s native image processing capabilities powered by GraphQL and Sharp. To produce perfect images with minimal effort, you can:

+ Install `gatsby-image` and other, necessary dependencies like `gatsby-plugin-sharp` and `gatsby-transformer-sharp`
+ Add the newly installed plugins and transformer plugins to your `gatsby-config.js`
+ Configure `gatsby-source-filesystem` to load images from a folder. In order to use GraphQL to query the image files, the files need to be in a location that is known to Gatsby. This requires an update to `gatsby-config.js` to configure the plugin. Feel free to replace the path option to reference wherever your images are located in your project.
+ Write a GraphQL query using one of the included GraphQL “fragments” which specify the fields needed by `gatsby-image` to create a responsive, optimized image. This example queries for an image at a path relative to the location specified in the `gatsby-source-filesystem` options using the `GatsbyImageSharpFluid` fragment. This GraphQL query creates multiple sizes of the image and when the page is rendered the image that is appropriate for the current screen resolution (e.g. desktop, mobile, and everything in between) is used. The gatsby-image component automatically enables a blur-up effect as well as lazy loading images that are not currently on screen.
+ Import `Img` to display the fragment in JSX. There are additional features available with the `Img` tag as well, such as the `alt` attribute for accessibility.

### Working with Images in Gatsby

Optimizing images is a challenge on any website. To utilize best practices for performance across devices, you need multiple sizes and resolutions of each image. Luckily, Gatsby has several useful [plugins](https://www.gatsbyjs.org/docs/plugins/) that work together to do that for images on [page components](https://www.gatsbyjs.org/docs/building-with-components/#page-components).

The recommended approach is to use [GraphQL queries](https://www.gatsbyjs.org/docs/querying-with-graphql/) to get images of the optimal size or resolution, then, display them with the `gatsby-image` component.

#### Query images with GraphQL

Querying images with GraphQL allows you to access the image’s data as well as perform transformations with [Sharp](https://github.com/lovell/sharp), a high-performance image processing library.

You’ll need a few plugins for this:

+ `gatsby-source-filesystem` plugin allows you to query files with GraphQL
+ `gatsby-plugin-sharp` powers the connections between Sharp and Gatsby Plugins
+ `gatsby-transformer-sharp` allows you to create multiples images of the right sizes and resolutions with a query

If the final image is of a fixed size, optimization relies on having multiple resolutions of the image. If it is responsive, that is it stretches to fill a container or page, optimization relies on having different sizes of the same image. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for more information.

You can also use arguments in your query to specify exact, minimum, and maximum dimensions. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for complete options.

#### Optimizing images with gatsby-image

`gatsby-image` is a plugin that automatically creates React components for optimized images that:

+ Loads the optimal size of image for each device size and screen resolution
+ Holds the image position while loading so your page doesn’t jump around as images load
+ Uses the “blur-up” effect i.e. it loads a tiny version of the image to show while the full image is loading
+ Alternatively provides a “traced placeholder” SVG of the image
+ Lazy loads images, which reduces bandwidth and speeds the initial load time
+ Uses WebP images, if browser supports the format

#### Using fragments to standardize formatting

What if you have a bunch of images and you want them all to use the same formatting?

A custom fragment is an easy way to standardize formatting and re-use it on multiple images:

```js
export const squareImage = graphql`
  fragment squareImage on File {
    childImageSharp {
      fluid(maxWidth: 200, maxHeight: 200) {
        ...GatsbyImageSharpFluid
      }
    }
  }
`
```

The fragment can then be referenced in the image query:

```js
export const query = graphql`
  query {
    image1: file(relativePath: { eq: "images/image1.jpg" }) {
      ...squareImage
    }

    image2: file(relativePath: { eq: "images/image2.jpg" }) {
      ...squareImage
    }

    image3: file(relativePath: { eq: "images/image3.jpg" }) {
      ...squareImage
    }
  }
`
```

### Preoptimizing Your Images

Gatsby ships with excellent image optimization capabilities (see the [image tutorial](https://www.gatsbyjs.org/tutorial/image-tutorial/) for more info). However, this image optimization can come with a cost. It can be fairly CPU intensive, and in some cases may lead to long build times. As a means of debugging and perhaps improving your overall build performance, it may be helpful to pre-optimize your (extremely large) images.

First, some context. `gatsby-plugin-sharp` ships with a `fluid` option which will attempt to create four images intended to map to various screen resolutions. Producing multiple images ensures that your images are ready and optimized for phone displays, desktop displays, and everything in between. This plugin receives a non-optimized image and produces optimized images for all of your users and devices. Magic!

If you find yourself running into build performance issues, it could be helpful to consider applying some image optimizations. Images in your setup could be overly large, especially compared to the requested image sizes in your layout (e.g. if your layout has a max width of 600 pixels).

For instance, if your layout is 600 pixels wide, then the highest resolution image you will need is 1200 pixels to account for 2x pixel density. If you have images that are 3000 or 4000 pixels wide then you could resize your image to 1800 pixels, which may improve overall build performance.

#### How to pre-optimize your images

Here’s an example script to pre-optimize your image dimensions and slightly compress. This optimization may serve as a helpful technique to possibly improve build time if your local repository has many, very large images.

```js
const sharp = require(`sharp`)
const glob = require(`glob`)
const fs = require(`fs-extra`)

const matches = glob.sync(`src/images/**/*.{png,jpg,jpeg}`)
const MAX_WIDTH = 1800
const QUALITY = 70

Promise.all(
  matches.map(async match => {
    const stream = sharp(match)
    const info = await stream.metadata()

    if (info.width < MAX_WIDTH) {
      return
    }

    const optimizedName = match.replace(
      /(\..+)$/,
      (match, ext) => `-optimized${ext}`
    )

    await stream
      .resize(MAX_WIDTH)
      .jpeg({ quality: QUALITY })
      .toFile(optimizedName)

    return fs.rename(optimizedName, match)
  })
)
```

The variables `MAX_WIDTH` and `QUALITY` should be configured in regards to your particular website’s layout. Quality can be lowered further for perhaps more gains in performance, but be aware that it can introduce visual differences between the original and optimized images, so be sure to compare before over optimizing.

### Working with Video

#### Sourcing video from a host

The easiest method for including video on a Gatsby site is to source an uploaded file from a site like YouTube, Vimeo, or Twitch. Using the source URL from one of those hosts, you can use Remark plugins or create a custom `<iframe>` solution to embed videos into your Gatsby site.

#### Embedding hosted videos in Markdown

There are numerous Gatsby plugins for working with hosted video in your Markdown posts and pages. We recommend checking out the [gatsby-remark-embed-video](https://www.gatsbyjs.org/packages/gatsby-remark-embed-video/?=video) plugin for sourcing from a variety of hosts like YouTube or vimeo.

##### Writing custom components for hosted video

If you would like more control over how YouTube (or similar) videos are embedded into your Gatsby posts and pages, you can write a reusable custom iframe component and include it in a JSX template or in your content with MDX.

In this reusable sample component, you could include props for video data like URL or title, any necessary markup for styling purposes, and the common iframe embed code:

```jsx
// src/components/video.js
import React from "react"
const Video = ({ videoSrcURL, videoTitle, ...props }) => (
  <div className="video">
    <iframe
      src={videoSrcURL}
      title={videoTitle}
      allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
      frameBorder="0"
      webkitallowfullscreen="true"
      mozallowfullscreen="true"
      allowFullScreen
    />
  </div>
)
export default Video
```

You would then include this component in a template or page with a video source URL and title passed in as props. The data for video URLs and titles can be sourced in multiple ways, such as importing JSON or [querying data from Markdown with GraphQL](https://www.gatsbyjs.org/docs/working-with-video/#querying-data-from-markdown-with-graphql). You can also hard-code video data for something fun, like a custom 404 page with an Easter egg YouTube video:

```jsx
// src/pages/404.js
import React from "react"

import Layout from "../components/layout"
import SEO from "../components/seo"
import Video from "../components/video"

const NotFoundPage = () => (
  <Layout>
    <SEO title="404: Not found" />
    <section>
      <h1>NOT FOUND</h1>
      <p>You just hit a page that doesn't exist... the sadness.</p>
      <p>May I suggest a video instead?</p>
      <Video
        videoSrcURL="https://www.youtube.com/embed/dQw4w9WgXcQ"
        videoTitle="Official Music Video on YouTube"
      />
    </section>
  </Layout>
)

export default NotFoundPage
```

#### Querying video data from Markdown with GraphQL

If a Markdown page or post has a featured video, you might want to include a video URL and title in its frontmatter. This allows you to pass those values into your custom component:

```md
---
path: "/blog/my-first-post"
date: "2019-03-27"
title: "My first blog post"
videoSourceURL: https://www.youtube.com/embed/dQw4w9WgXcQ
videoTitle: "Gatsby is Never Gonna Give You Up"
---
```

To include a video component in a template, you could start with something like this:

```jsx
import React from "react"
import { graphql } from "gatsby"

import Video from "../components/video"

export default function VlogTemplate({
  data, // this prop will be injected by the GraphQL query below.
}) {
  const { markdownRemark } = data // data.markdownRemark holds your post data
  const { frontmatter, html } = markdownRemark
  return (
    <div className="blog-post-container">
      <div className="blog-post">
        <h1>{frontmatter.title}</h1>
        <h2>{frontmatter.date}</h2>
        <Video
          videoSrcURL={frontmatter.videoSrcURL}
          videoTitle={frontmatter.videoTitle}
        />
        <div
          className="blog-post-content"
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
    </div>
  )
}

export const pageQuery = graphql`
  query($path: String!) {
    markdownRemark(frontmatter: { path: { eq: $path } }) {
      html
      frontmatter {
        date(formatString: "MMMM DD, YYYY")
        path
        title
        videoSrcURL
        videoTitle
      }
    }
  }
`
```

#### Hosting your own HTML5 video files

It’s super common to source video from YouTube, Twitch or Vimeo. But what if you want to host your own video and include it as HTML5 video?

To include your own video files that will work in multiple web browsers and platforms, you’ll need to read up a bit on video extensions and codecs. We recommend MDN as a resource: [Media formats for HTML audio and video](https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats). You may need video converter software to produce the necessary formats — such as `.webm` and `.mp4` — to support a range of devices and environments.

HTML5 provides the `<video>` media element for working with videos. Inside the `<video>` element, you can provide multiple `<source>` elements that serve as different file formats the video player can use, with each browser electing to use a format it supports.

If you have a video called `dog.mp4` in your site under `src/assets/dog.mp4`, you can include that video in your page with webpack like you would other assets. Then reference it in a `<source>` element, which is wrapped by a `<video>` element:

```jsx
// src/pages/index.js
import React from "react"
import DogVideo from "../assets/dog.mp4"

export default () => (
  <video controls>
    <source src={DogVideo} type="video/mp4" />
  </video>
)
```

The controls attribute on the `<video>` will provide a default set of buttons overlaid on the video to play/pause, adjust volume, and go full screen. Other attributes like `muted` can set audio to silent, or `poster` can display an image when the video isn’t playing. Common attributes that you’d want to apply to multiple videos could be extracted into a custom React video component. A full list of `<video>` attributes can be found on [the MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#Attributes).

##### Supporting multiple browsers and formats

Adding more source tags for additional formats will allow the browser to find a source type that it supports, if there are no matching source types the video will fail to load. You can see what formats are supported in different browsers on [MDN’s docs about supported media formats](https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility).

```jsx
// src/pages/index.js
import React from "react"
import DogMp4 from "../assets/dog.mp4"
import DogOgg from "../assets/dog.ogg"

export default () => (
  <video controls>
    <source src={DogMp4} type="video/mp4" />
    <source src={DogOgg} type="video/ogg" />
  </video>
)
```

Even though there are two `<source>` elements, only one video will be displayed, first `.mp4` if it is supported, then `.ogg`.

Note: This requires importing a video in the format of the type specified, i.e. adding a `<source>` element with `type=video/ogg` would also need a file import with a format of .ogg. Alternatively, you can specify a URL to where a video is remotely hosted as the `src` instead of importing a local file.

See an [example repository using `<video>` elements](https://github.com/gatsbyjs/gatsby/blob/master/examples/using-video/)

##### Accessibility with custom video players

One advantage of integrating a custom component with your own hosted video is it can give you more control over the video player, including its accessibility. Elements of accessible video and audio include:

+ captions: a text version of the audio, synchronized with the video
+ transcript (or subtitles): a text version of the audio and visual content, like captions but also including descriptions of key visual elements in the video
+ audio description: an audio version of visual information not conveyed in dialogue
+ accessible controls: buttons to operate the video that can be operated without a mouse, are labeled, and work across environments and browsers

Though captions, transcripts, and audio descriptions primarily aim to assist those with greater difficulty seeing or hearing, they benefit many other users who prefer reading to listening. Captions can also help people watching videos when they can’t have the sound turned on for whatever reason.

HTML5 provides support for these types of assistive content through the `<track>` element. The track element is nested under a `<video>` element as an empty tag. An example usage of the `<track>` element with a video looks like this:

```jsx
// src/pages/index.js
import React from "react"
import DogMp4 from "../assets/dog.mp4"
import Captions from "file-loader!../assets/captions.vtt"

export default () => (
  <video controls>
    <source src={DogMp4} type="video/mp4" />
    <track kind="captions" srcLang="en" src={Captions} />
  </video>
)
```

The kind attribute can be of a variety of different types including `captions`, `subtitles`, and `descriptions`, among others. The `srcLang` defines English as the language used in the captions in the example, and the captions file imported is used as the source. You can read about the specific attributes of a `<track>` [on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track).

Note: The filepath to import the captions in the above code snippet includes the `file-loader!` prefix, which helps webpack import the `.vtt` caption file.

Check out the accessible [HTML5 video player from PayPal](https://github.com/paypal/accessible-html5-video-player#react-version) for an example compatible with Gatsby and React.

### Importing Media Content

### Working with GIFs

### Working with Images in Markdown

### Preprocessing External Images
