# Day 18 - Saturday, January 18th, 2020

Today's focus is on [Images, Files & Video in Gatsby](https://www.gatsbyjs.org/docs/images-and-files/)

## Scratchpad

To create a new Gatsby app, I will use `npx` to create a new [Gatsby](https://www.gatsbyjs.com) app using the latest version of the [Gatsby CLI](https://www.gatsbyjs.com):

```sh
# Generate a new app using the latest version of the Gatsby CLI
$ npx gatsby new app
  # OPTIONAL: Copy the Dockerized Gatsby CLI example to an appropriate folder for a faster starting point
  $ cp -r 100-days-of-gatsby/default-gatsby-cli-app-dockerized 100-days-of-gatsby/day-##

# Navigate to the appropriate example directory
$ cd 100-days-of-gatsby/day-##

# Navigate to the app directory
$ cd app
```

## Images, Files & Video in Gatsby

Gatsby provides multiple solutions for adding images, video, and files to your projects. And a pro tip: you don’t necessarily have to use GraphQL! From [imports](https://www.gatsbyjs.org/docs/importing-assets-into-files/) and use of the [static folder](https://www.gatsbyjs.org/docs/static-folder/) to dynamic queries with [Gatsby Image](https://www.gatsbyjs.org/docs/using-gatsby-image/) to prevent image bloat, you’ve got options.

This section will walk you through several common patterns for handling media with Gatsby, where you can learn about the pros and cons of each method.

### Importing Assets Directly into Files

#### Importing assets with Webpack

With Webpack you can import a file right in a JavaScript module. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This imported file’s value is the final path you can reference in your code, e.g. as the src attribute of an image or the href of a link to a PDF.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: svg, jpg, jpeg, png, gif, mp4, webm, wav, mp3, m4a, aac, and oga.

Here’s an example:

```jsx
import React from "react"
import logo from "./logo.png" // Tell Webpack this JS file uses this image

console.log(logo) // /logo.84287d09.png

function Header() {
  // Import result is the URL of your image
  return <img src={logo} alt="Logo" />
}

export default Header
```

This ensures that when the project is built, Webpack will correctly move the images into the public folder, and provide us with correct paths.

You can reference files in CSS to import them, too:

```css
.Logo {
  background-image: url(./logo.png);
}
```

Webpack finds all relative module references in CSS (they start with ./) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets.

If you’re using SCSS the imports are relative to the entry SCSS file.

Please be advised that this is also a custom feature of Webpack.

#### Querying for a File in GraphQL using gatsby-source-filesystem

You can also import files using GraphQL by querying for them in your data layer, which will trigger copying of those files to the public directory. Querying for the `publicURL` field of `File` nodes will provide URLs you can use in your JavaScript components, pages and templates.

##### Example: Copy all .pdf files you have in your data layer to your build directory and return URLs to them:

```graphql
{
  allFile(filter: { extension: { eq: "pdf" } }) {
    edges {
      node {
        publicURL
      }
    }
  }
}
```

Reference those PDF files in a page with useStaticQuery:

```jsx
import React from "react"
import { useStaticQuery, graphql } from "gatsby"

import Layout from "../components/layout"

const DownloadsPage = () => {
  const data = useStaticQuery(graphql`
    {
      allFile(filter: { extension: { eq: "pdf" } }) {
        edges {
          node {
            publicURL
            name
          }
        }
      }
    }
  `)
  return (
    <Layout>
      <h1>All PDF Downloads</h1>
      <ul>
        {data.allFile.edges.map((file, index) => {
          return (
            <li key={`pdf-${index}`}>
              <a href={file.node.publicURL} download>
                {file.node.name}
              </a>
            </li>
          )
        })}
      </ul>
    </Layout>
  )
}
export default DownloadsPage
```

##### Example: Link to attachments in the frontmatter of your Markdown files:

```md
---
title: "Title of article"
attachments:
  - "./assets.zip"
  - "./presentation.pdf"
---

Hi, this is a great article.
```

In an article template component file, you can then query for the attachments:

```graphql
query($slug: String!) {
  markdownRemark(fields: { slug: { eq: $slug } }) {
    html
    frontmatter {
      title
      attachments {
        publicURL
      }
    }
  }
}
```

### Using the Static Folder

In general, every website needs assets: images, stylesheets, scripts, etc. When using Gatsby, we recommend Importing Assets Directly in JavaScript files, because of the benefits it provides:

+ Scripts and stylesheets are minified and bundled together to avoid extra network requests.
+ Missing files cause compilation errors instead of 404 errors for your users.
+ Result filenames include content hashes so you don’t need to worry about browsers caching their old versions.

However, there is an escape hatch that you can use to add an asset outside of the module system.

#### Adding assets outside of the module system

You can create a folder named static at the root of your project. Every file you put into that folder will be copied into the public folder. E.g. if you add a file named `sun.jpg` to the static folder, it’ll be copied to `public/sun.jpg`

##### Referencing your static asset

You can reference assets from the static folder in your code without anything special required:

```jsx
render() {
  // Note: this is an escape hatch and should be used sparingly!
  // Normally we recommend using `import` for getting asset URLs
  // as described in the “Importing Assets Directly Into Files” page.
  return <img src={'/logo.png'} alt="Logo" />;
}
```

##### Downsides

Keep in mind the downsides of this approach:

+ None of the files in the `static` folder will be post-processed or minified.
+ Missing files will not be called at compilation time, and will cause 404 errors for your users.
+ Result filenames won’t include content hashes, so you’ll need to add query arguments or rename them every time they change.

#### When to use the static folder

Normally we recommend importing stylesheets, images, and font assets from JavaScript. The static folder is useful as a workaround for a number of less common cases:

+ You need a file with a specific name in the build output, such as manifest.webmanifest.
+ You have thousands of images and need to dynamically reference their paths.
+ You want to include a small script like pace.js outside of the bundled code.
+ Some libraries may be incompatible with Webpack and you have no other option but to include it as a <script> tag.
+ You need to import JSON file that doesn’t have a consistent schema, like TopoJSON files, which is difficult to handle with GraphQL. Note that importing JSON files directly inside a page, a template, or a component using import syntax results in adding that file to the app bundle and increasing the size of all site’s pages. Instead, it’s better to place your JSON file inside the static folder and use the dynamic import syntax (import('/static/myjson.json')) within the componentDidMount lifecycle or the useEffect hook.

### Using gatsby-image

`gatsby-image` is a React component designed to work seamlessly with Gatsby’s GraphQL queries (gatsby-image plugin README). It combines Gatsby’s native image processing capabilities with advanced image loading techniques to easily and completely optimize image loading for your sites. `gatsby-image` uses `gatsby-plugin-sharp` to power its image transformations.

Warning: `gatsby-image` is not a drop-in replacement for `<img />`. It’s optimized for fixed width/height images and images that stretch the full width of a container. Some ways you can use `<img />` won’t work with `gatsby-image`.

`gatsby-image` includes the tricks you’d expect from a modern image component. It:

+ uses the new [IntersectionObserver API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) to cheaply lazy load images
+ holds an image’s position so your page doesn’t jump around as images load
+ makes it easy to add a placeholder—either a gray background or a blurry version of the image.

For more complete API information, check out the [Gatsby Image API](https://www.gatsbyjs.org/docs/gatsby-image/) docs.

#### Problem

Large, unoptimized images dramatically slow down your site.

But creating optimized images for websites has long been a thorny problem. Ideally, you would:

+ Resize large images to the size needed by your design
+ Generate multiple smaller images so smartphones and tablets don’t download desktop-sized images
+ Strip all unnecessary metadata and optimize JPEG and PNG compression
+ Efficiently lazy load images to speed initial page load and save bandwidth
+ Use the “blur-up” technique or a “traced placeholder” SVG to show a preview of the image while it loads
+ Hold the image position so your page doesn’t jump while the images load
+ Doing this consistently across a site feels like Sisyphean labor. You manually optimize your images and then… several images are swapped in at the last minute or a design-tweak shaves 100px of width off your images.

Most solutions involve a lot of manual labor and bookkeeping to ensure every image is optimized.

This isn’t ideal. Optimized images should be easy and the default.

#### Solution

With Gatsby, you can make the experience of working with images way, way better.

`gatsby-image` is designed to work seamlessly with Gatsby’s native image processing capabilities powered by GraphQL and Sharp. To produce perfect images with minimal effort, you can:

+ Install `gatsby-image` and other, necessary dependencies like `gatsby-plugin-sharp` and `gatsby-transformer-sharp`
+ Add the newly installed plugins and transformer plugins to your `gatsby-config.js`
+ Configure `gatsby-source-filesystem` to load images from a folder. In order to use GraphQL to query the image files, the files need to be in a location that is known to Gatsby. This requires an update to `gatsby-config.js` to configure the plugin. Feel free to replace the path option to reference wherever your images are located in your project.
+ Write a GraphQL query using one of the included GraphQL “fragments” which specify the fields needed by `gatsby-image` to create a responsive, optimized image. This example queries for an image at a path relative to the location specified in the `gatsby-source-filesystem` options using the `GatsbyImageSharpFluid` fragment. This GraphQL query creates multiple sizes of the image and when the page is rendered the image that is appropriate for the current screen resolution (e.g. desktop, mobile, and everything in between) is used. The gatsby-image component automatically enables a blur-up effect as well as lazy loading images that are not currently on screen.
+ Import `Img` to display the fragment in JSX. There are additional features available with the `Img` tag as well, such as the `alt` attribute for accessibility.

### Working with Images in Gatsby

Optimizing images is a challenge on any website. To utilize best practices for performance across devices, you need multiple sizes and resolutions of each image. Luckily, Gatsby has several useful [plugins](https://www.gatsbyjs.org/docs/plugins/) that work together to do that for images on [page components](https://www.gatsbyjs.org/docs/building-with-components/#page-components).

The recommended approach is to use [GraphQL queries](https://www.gatsbyjs.org/docs/querying-with-graphql/) to get images of the optimal size or resolution, then, display them with the `gatsby-image` component.

#### Query images with GraphQL

Querying images with GraphQL allows you to access the image’s data as well as perform transformations with [Sharp](https://github.com/lovell/sharp), a high-performance image processing library.

You’ll need a few plugins for this:

+ `gatsby-source-filesystem` plugin allows you to query files with GraphQL
+ `gatsby-plugin-sharp` powers the connections between Sharp and Gatsby Plugins
+ `gatsby-transformer-sharp` allows you to create multiples images of the right sizes and resolutions with a query

If the final image is of a fixed size, optimization relies on having multiple resolutions of the image. If it is responsive, that is it stretches to fill a container or page, optimization relies on having different sizes of the same image. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for more information.

You can also use arguments in your query to specify exact, minimum, and maximum dimensions. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for complete options.

#### Optimizing images with gatsby-image

`gatsby-image` is a plugin that automatically creates React components for optimized images that:

+ Loads the optimal size of image for each device size and screen resolution
+ Holds the image position while loading so your page doesn’t jump around as images load
+ Uses the “blur-up” effect i.e. it loads a tiny version of the image to show while the full image is loading
+ Alternatively provides a “traced placeholder” SVG of the image
+ Lazy loads images, which reduces bandwidth and speeds the initial load time
+ Uses WebP images, if browser supports the format

#### Using fragments to standardize formatting

What if you have a bunch of images and you want them all to use the same formatting?

A custom fragment is an easy way to standardize formatting and re-use it on multiple images:

```js
export const squareImage = graphql`
  fragment squareImage on File {
    childImageSharp {
      fluid(maxWidth: 200, maxHeight: 200) {
        ...GatsbyImageSharpFluid
      }
    }
  }
`
```

The fragment can then be referenced in the image query:

```js
export const query = graphql`
  query {
    image1: file(relativePath: { eq: "images/image1.jpg" }) {
      ...squareImage
    }

    image2: file(relativePath: { eq: "images/image2.jpg" }) {
      ...squareImage
    }

    image3: file(relativePath: { eq: "images/image3.jpg" }) {
      ...squareImage
    }
  }
`
```

### Preoptimizing Your Images

Gatsby ships with excellent image optimization capabilities (see the [image tutorial](https://www.gatsbyjs.org/tutorial/image-tutorial/) for more info). However, this image optimization can come with a cost. It can be fairly CPU intensive, and in some cases may lead to long build times. As a means of debugging and perhaps improving your overall build performance, it may be helpful to pre-optimize your (extremely large) images.

First, some context. `gatsby-plugin-sharp` ships with a `fluid` option which will attempt to create four images intended to map to various screen resolutions. Producing multiple images ensures that your images are ready and optimized for phone displays, desktop displays, and everything in between. This plugin receives a non-optimized image and produces optimized images for all of your users and devices. Magic!

If you find yourself running into build performance issues, it could be helpful to consider applying some image optimizations. Images in your setup could be overly large, especially compared to the requested image sizes in your layout (e.g. if your layout has a max width of 600 pixels).

For instance, if your layout is 600 pixels wide, then the highest resolution image you will need is 1200 pixels to account for 2x pixel density. If you have images that are 3000 or 4000 pixels wide then you could resize your image to 1800 pixels, which may improve overall build performance.

#### How to pre-optimize your images

Here’s an example script to pre-optimize your image dimensions and slightly compress. This optimization may serve as a helpful technique to possibly improve build time if your local repository has many, very large images.

```js
const sharp = require(`sharp`)
const glob = require(`glob`)
const fs = require(`fs-extra`)

const matches = glob.sync(`src/images/**/*.{png,jpg,jpeg}`)
const MAX_WIDTH = 1800
const QUALITY = 70

Promise.all(
  matches.map(async match => {
    const stream = sharp(match)
    const info = await stream.metadata()

    if (info.width < MAX_WIDTH) {
      return
    }

    const optimizedName = match.replace(
      /(\..+)$/,
      (match, ext) => `-optimized${ext}`
    )

    await stream
      .resize(MAX_WIDTH)
      .jpeg({ quality: QUALITY })
      .toFile(optimizedName)

    return fs.rename(optimizedName, match)
  })
)
```

The variables `MAX_WIDTH` and `QUALITY` should be configured in regards to your particular website’s layout. Quality can be lowered further for perhaps more gains in performance, but be aware that it can introduce visual differences between the original and optimized images, so be sure to compare before over optimizing.

### Working with Video

#### Sourcing video from a host

The easiest method for including video on a Gatsby site is to source an uploaded file from a site like YouTube, Vimeo, or Twitch. Using the source URL from one of those hosts, you can use Remark plugins or create a custom `<iframe>` solution to embed videos into your Gatsby site.

#### Embedding hosted videos in Markdown

There are numerous Gatsby plugins for working with hosted video in your Markdown posts and pages. We recommend checking out the [gatsby-remark-embed-video](https://www.gatsbyjs.org/packages/gatsby-remark-embed-video/?=video) plugin for sourcing from a variety of hosts like YouTube or vimeo.

##### Writing custom components for hosted video

If you would like more control over how YouTube (or similar) videos are embedded into your Gatsby posts and pages, you can write a reusable custom iframe component and include it in a JSX template or in your content with MDX.

In this reusable sample component, you could include props for video data like URL or title, any necessary markup for styling purposes, and the common iframe embed code:

```jsx
// src/components/video.js
import React from "react"
const Video = ({ videoSrcURL, videoTitle, ...props }) => (
  <div className="video">
    <iframe
      src={videoSrcURL}
      title={videoTitle}
      allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
      frameBorder="0"
      webkitallowfullscreen="true"
      mozallowfullscreen="true"
      allowFullScreen
    />
  </div>
)
export default Video
```

You would then include this component in a template or page with a video source URL and title passed in as props. The data for video URLs and titles can be sourced in multiple ways, such as importing JSON or [querying data from Markdown with GraphQL](https://www.gatsbyjs.org/docs/working-with-video/#querying-data-from-markdown-with-graphql). You can also hard-code video data for something fun, like a custom 404 page with an Easter egg YouTube video:

```jsx
// src/pages/404.js
import React from "react"

import Layout from "../components/layout"
import SEO from "../components/seo"
import Video from "../components/video"

const NotFoundPage = () => (
  <Layout>
    <SEO title="404: Not found" />
    <section>
      <h1>NOT FOUND</h1>
      <p>You just hit a page that doesn't exist... the sadness.</p>
      <p>May I suggest a video instead?</p>
      <Video
        videoSrcURL="https://www.youtube.com/embed/dQw4w9WgXcQ"
        videoTitle="Official Music Video on YouTube"
      />
    </section>
  </Layout>
)

export default NotFoundPage
```

#### Querying video data from Markdown with GraphQL

If a Markdown page or post has a featured video, you might want to include a video URL and title in its frontmatter. This allows you to pass those values into your custom component:

```md
---
path: "/blog/my-first-post"
date: "2019-03-27"
title: "My first blog post"
videoSourceURL: https://www.youtube.com/embed/dQw4w9WgXcQ
videoTitle: "Gatsby is Never Gonna Give You Up"
---
```

To include a video component in a template, you could start with something like this:

```jsx
import React from "react"
import { graphql } from "gatsby"

import Video from "../components/video"

export default function VlogTemplate({
  data, // this prop will be injected by the GraphQL query below.
}) {
  const { markdownRemark } = data // data.markdownRemark holds your post data
  const { frontmatter, html } = markdownRemark
  return (
    <div className="blog-post-container">
      <div className="blog-post">
        <h1>{frontmatter.title}</h1>
        <h2>{frontmatter.date}</h2>
        <Video
          videoSrcURL={frontmatter.videoSrcURL}
          videoTitle={frontmatter.videoTitle}
        />
        <div
          className="blog-post-content"
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
    </div>
  )
}

export const pageQuery = graphql`
  query($path: String!) {
    markdownRemark(frontmatter: { path: { eq: $path } }) {
      html
      frontmatter {
        date(formatString: "MMMM DD, YYYY")
        path
        title
        videoSrcURL
        videoTitle
      }
    }
  }
`
```

#### Hosting your own HTML5 video files

It’s super common to source video from YouTube, Twitch or Vimeo. But what if you want to host your own video and include it as HTML5 video?

To include your own video files that will work in multiple web browsers and platforms, you’ll need to read up a bit on video extensions and codecs. We recommend MDN as a resource: [Media formats for HTML audio and video](https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats). You may need video converter software to produce the necessary formats — such as `.webm` and `.mp4` — to support a range of devices and environments.

HTML5 provides the `<video>` media element for working with videos. Inside the `<video>` element, you can provide multiple `<source>` elements that serve as different file formats the video player can use, with each browser electing to use a format it supports.

If you have a video called `dog.mp4` in your site under `src/assets/dog.mp4`, you can include that video in your page with webpack like you would other assets. Then reference it in a `<source>` element, which is wrapped by a `<video>` element:

```jsx
// src/pages/index.js
import React from "react"
import DogVideo from "../assets/dog.mp4"

export default () => (
  <video controls>
    <source src={DogVideo} type="video/mp4" />
  </video>
)
```

The controls attribute on the `<video>` will provide a default set of buttons overlaid on the video to play/pause, adjust volume, and go full screen. Other attributes like `muted` can set audio to silent, or `poster` can display an image when the video isn’t playing. Common attributes that you’d want to apply to multiple videos could be extracted into a custom React video component. A full list of `<video>` attributes can be found on [the MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#Attributes).

##### Supporting multiple browsers and formats

Adding more source tags for additional formats will allow the browser to find a source type that it supports, if there are no matching source types the video will fail to load. You can see what formats are supported in different browsers on [MDN’s docs about supported media formats](https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility).

```jsx
// src/pages/index.js
import React from "react"
import DogMp4 from "../assets/dog.mp4"
import DogOgg from "../assets/dog.ogg"

export default () => (
  <video controls>
    <source src={DogMp4} type="video/mp4" />
    <source src={DogOgg} type="video/ogg" />
  </video>
)
```

Even though there are two `<source>` elements, only one video will be displayed, first `.mp4` if it is supported, then `.ogg`.

Note: This requires importing a video in the format of the type specified, i.e. adding a `<source>` element with `type=video/ogg` would also need a file import with a format of .ogg. Alternatively, you can specify a URL to where a video is remotely hosted as the `src` instead of importing a local file.

See an [example repository using `<video>` elements](https://github.com/gatsbyjs/gatsby/blob/master/examples/using-video/)

##### Accessibility with custom video players

One advantage of integrating a custom component with your own hosted video is it can give you more control over the video player, including its accessibility. Elements of accessible video and audio include:

+ captions: a text version of the audio, synchronized with the video
+ transcript (or subtitles): a text version of the audio and visual content, like captions but also including descriptions of key visual elements in the video
+ audio description: an audio version of visual information not conveyed in dialogue
+ accessible controls: buttons to operate the video that can be operated without a mouse, are labeled, and work across environments and browsers

Though captions, transcripts, and audio descriptions primarily aim to assist those with greater difficulty seeing or hearing, they benefit many other users who prefer reading to listening. Captions can also help people watching videos when they can’t have the sound turned on for whatever reason.

HTML5 provides support for these types of assistive content through the `<track>` element. The track element is nested under a `<video>` element as an empty tag. An example usage of the `<track>` element with a video looks like this:

```jsx
// src/pages/index.js
import React from "react"
import DogMp4 from "../assets/dog.mp4"
import Captions from "file-loader!../assets/captions.vtt"

export default () => (
  <video controls>
    <source src={DogMp4} type="video/mp4" />
    <track kind="captions" srcLang="en" src={Captions} />
  </video>
)
```

The kind attribute can be of a variety of different types including `captions`, `subtitles`, and `descriptions`, among others. The `srcLang` defines English as the language used in the captions in the example, and the captions file imported is used as the source. You can read about the specific attributes of a `<track>` [on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track).

Note: The filepath to import the captions in the above code snippet includes the `file-loader!` prefix, which helps webpack import the `.vtt` caption file.

Check out the accessible [HTML5 video player from PayPal](https://github.com/paypal/accessible-html5-video-player#react-version) for an example compatible with Gatsby and React.

### Importing Media Content

“Media content” is a broad term that generally includes images, videos, documents and files that are displayed on your website. For Gatsby sites, you have multiple options for importing media content depending on the type:

#### Images, SVG, and PDFs

+ [Image graphics can be imported](https://www.gatsbyjs.org/docs/importing-assets-into-files/) with Webpack and queried with GraphQL.
+ Images can also be [included from the static folder](https://www.gatsbyjs.org/docs/static-folder/).
+ SVG content can be embedded into JSX. Here’s a [handy JSX converter](https://transform.tools/svg-to-jsx).
+ SVG can be included in `img` tags or CSS backgrounds. [SVG Tips from CSS Tricks](https://css-tricks.com/using-svg/).
+ For PDF files, we recommend embedding an [image of the PDF](https://helpx.adobe.com/acrobat/using/exporting-pdfs-file-formats.html) with [alternative text](https://a11y-101.com/development/infographics), and providing a link to download a [tagged PDF](https://helpx.adobe.com/acrobat/using/creating-accessible-pdfs.html).

#### Video assets

Like images, video assets present many options and requirements for cross-browser support. Learn about video embeds on the Gatsby docs page on [working with video](https://www.gatsbyjs.org/docs/working-with-video/) section.

#### Canvas and WebGL

The HTML5 `<canvas>` element provides a space for 2-dimensional drawing in a web environment. In Gatsby and React, it may help to include a library like [react-konva](https://github.com/konvajs/react-konva) or one of the comparison libraries to cut down on boilerplate and make drawing easier.

[WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL), on the other hand, creates a 3-dimensional space in a web environment using the `<canvas>` element. Libraries like [Three.js](https://threejs.org/) are often used to enable WebGL experiences in React apps.

> Using canvas and/or WebGL may require modifying your Webpack config. Do you have experience with making this work in your Gatsby site? Contribute to the docs by adding more details to this page.

### Working with GIFs

If you’re building a blog with Gatsby, chances are you’ll want to include some animated GIFs: who wouldn’t want to include a dancing otter or cat GIF?

#### Including GIFs in components

In Gatsby components and pages, you’ll want to import animated GIFs instead of using Gatsby Image because of the way it optimizes image data for the responsive picture element.

Here’s an example:

```jsx
// pages/about.js
import React from 'react'

import Layout from '../components/layout'
import otterGIF from '../gifs/otter.gif'

const AboutPage = () => (
    return (
        <Layout>
            <img src={otterGIF} alt="Otter dancing with a fish" />
        </Layout>
    )
)

export default AboutPage;
```

#### Including GIFs in Markdown

In Markdown posts and pages, including an animated GIF is the same as a static image:

```md
![otter dancing with a fish](./images/dancing-ofter.gif)
```

Animated GIFs can be quite large in size, so be careful not to sabotage your webpages’ performance with extremely large files. You could reduce file size by [optimizing the frames](https://skylilies.livejournal.com/244378.html) or converting them to video.

#### Accessibility concerns with animated GIFs

Beware that flashing and autoplaying GIFs can cause issues for users who are sensitive to motion. GIFs should not autoplay whenever possible for safety reasons. One technique would be to add controls, such as using a package like [react-gif-player](https://www.npmjs.com/package/react-gif-player) as a [client-only package](https://www.gatsbyjs.org/docs/using-client-side-only-packages/).

For more information on accessible motion:

+ [https://source.opennews.org/articles/motion-sick/](https://source.opennews.org/articles/motion-sick/)
+ [https://www.w3.org/TR/UNDERSTANDING-WCAG20/time-limits-pause.html](https://www.w3.org/TR/UNDERSTANDING-WCAG20/time-limits-pause.html)

### Working with Images in Markdown

When building Gatsby sites composed primarily of Markdown pages or posts, insertion of images can enhance the content. You can add images in multiple ways.

#### Featured images with Frontmatter metadata

In sites like a blog, you may want to include a featured image that appears at the top of a page. One way to do this is to grab the image filename from a frontmatter field and then transform it with `gatsby-plugin-sharp` in a GraphQL query.

This solution assumes you already have programmatically generated pages from Markdown with renderers like `gatsby-transformer-remark` or `gatsby-plugin-mdx`. If not, take a read through up to Part 7 of the Gatsby Tutorial. This will build upon the tutorial and as such, `gatsby-transformer-remark` will be used for this example.

> Note: This can be done similarly using [MDX](https://www.gatsbyjs.org/docs/mdx/) as well. Instead of the `markdownRemark` nodes in GraphQL, `Mdx` can be swapped in and should work.

##### Configuring for images and posts in the same directory

If your images are in the same directory as the Markdown files, sourcing and resolving the images can be done in one configuration. For example, if your Markdown pages and images are located together in a `/pages` directory, both content types will be automatically picked up by GraphQL as part of Gatsby’s data layer.

```js
// gatsby-config.js
module.exports = {
  plugins: [
    `gatsby-plugin-sharp`,
    `gatsby-transformer-sharp`,
    `gatsby-transformer-remark`,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/pages`,
      },
    },
  ],
}
```

Then, in an example Markdown file, add a field called `featuredImage`:

```md
---
title: My Favorite Doggos
featuredImage: pupperino.png
---

Content goes here!
```

The next step will be to incorporate the data into a template with a GraphQL query, which can be found later in this guide.

##### Configuring for images and posts in different directories

There are also occassions when you may want to source images from a different directory than where your Markdown posts or pages are located, such as in an external `/images` folder. You can set this up by specifying two distinct sources, one for the pages and the other for images:

```js
// gatsby-config.js
module.exports = {
  plugins: [
    `gatsby-plugin-sharp`,
    `gatsby-transformer-sharp`,
    `gatsby-transformer-remark`,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/pages`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/images`,
      },
    },
  ],
}
```

Then, in a Markdown file, the path to a `featuredImage` would be relative to the page file (in this case, in an `/images` directory up a level):

```md
---
title: About
featuredImage: ../images/team-cat.png
---

Content goes here!
```

##### Querying for images from Frontmatter

Now that you’ve sourced Markdown and image data, you can query for featured images in GraphQL. If a filepath points to an actual image, it will be transformed into a `File` node in GraphQL and then you can get the image data out of it by using the `childImageSharp` field.

This can be added to the GraphQL query in a Markdown template file. In this example, a [Fluid query](https://www.gatsbyjs.org/docs/gatsby-image#images-that-stretch-across-a-fluid-container) is used to make a responsive image.

```js
// src/templates/blog-post.js
export const query = graphql`
  query PostQuery($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      html
      frontmatter {
        title
        featuredImage {
          childImageSharp {
            fluid(maxWidth: 800) {
              ...GatsbyImageSharpFluid
            }
          }
        }
      }
    }
  }
`
```

Also in the Markdown post template, import the `gatsby-image` package and pass the results of the GraphQL query into an `<Img />` component.

```js
// src/templates/blog-post.js
import React from "react"
import { graphql } from "gatsby"
import Layout from "../components/layout"
import Img from "gatsby-image"

export default ({ data }) => {
  let post = data.markdownRemark

  let featuredImgFluid = post.frontmatter.featuredImage.childImageSharp.fluid

  return (
    <Layout>
      <div>
        <h1>{post.frontmatter.title}</h1>
        <Img fluid={featuredImgFluid} />
        <div dangerouslySetInnerHTML={{ __html: post.html }} />
      </div>
    </Layout>
  )
}

export const query = graphql`
  query PostQuery($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      html
      frontmatter {
        title
        featuredImage {
          childImageSharp {
            fluid(maxWidth: 800) {
              ...GatsbyImageSharpFluid
            }
          }
        }
      }
    }
  }
`
```

Your featured image should now appear on the generated page right below the main header. Tada!

#### Inline images with gatsby-remark-images

You may also include images in the Markdown body itself. The plugin `gatsby-remark-images` comes in handy for this - along with `gatsby-plugin-sharp`.

##### Using the MDX Plugin

The `gatsby-plugin-mdx` plugin will be used in the example below. Put the `gatsby-remark-images` plugin within the `gatsbyRemarkPlugins` option field of `gatsby-plugin-mdx`.

> Note: This example configuration assumes your images and Markdown pages are sourced from the same directory. Check out the section on [configuring for different directories](https://www.gatsbyjs.org/docs/working-with-images-in-markdown/#configuring-for-images-and-posts-in-different-directories) for additional help.

```js
// gatsby-config.js
module.exports = {
  plugins: [
    `gatsby-plugin-sharp`,
    {
      resolve: `gatsby-plugin-mdx`,
      options: {
        gatsbyRemarkPlugins: [
          {
            resolve: `gatsby-remark-images`,
            options: {
              maxWidth: 1200,
            },
          },
        ],
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/pages`,
      },
    },
  ],
}
```

##### Using the Transformer Remark Plugin

Here is a similar example using the `gatsby-transformer-remark` plugin instead of `gatsby-plugin-mdx`. Put the `gatsby-remark-images` plugin within the `plugins` option field of `gatsby-transformer-remark`.

```js
// gatsby-config.js
module.exports = {
  plugins: [
    `gatsby-plugin-sharp`,
    {
      resolve: `gatsby-transformer-remark`,
      options: {
        plugins: [
          {
            resolve: `gatsby-remark-images`,
            options: {
              maxWidth: 800,
            },
          },
        ],
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/src/posts`,
      },
    },
  ],
}
```

With the configurations above, you can use the default Markdown syntax for images. They will be processed by Sharp and appear as if you placed them in a `gatsby-image` component.

```md
![Hopper The Rabbit](./rabbit-friend.png)
```

### Preprocessing External Images

Gatsby allows powerful image processing features using the `Sharp` library to automatically process images to be performant, with features like lazy-loading. That said, this only works if the image is a `File` node in the GraphQL layer.

If you want the same functionality for files that are remotely hosted online and not located in your Git repo, `gatsby-source-filesystem` has an API called `createRemoteFileNode` to solve this.

This guide will show you how to use the `createRemoteFileNode` process and get the same benefits of `gatsby-transformer-sharp` with externally sourced images.

#### Setup

A use case that this technique can support is if you want to create a featured image in a blog post with an image sourced from a URL out on the web, instead of a local file. This could be hosted somewhere like Imgur, S3, or anywhere on the internet.

Given a sample post:

```md
---
title: My first blog post!
featuredImgUrl: https://images.unsplash.com/photo-1560237731-890b122a9b6c
featuredImgAlt: Mountains with a starry sky
---

Hello World
```

You can use a custom Frontmatter field for the URL of the featured image you want to pull down and use as part of the site.

By default, this is a string value as you haven’t told Gatsby yet how to interpret it. However, you can add some code into `gatsby-node.js` to modify it.

#### Gatsby Node

In your `gatsby-node.js` file, you can do some processing to create file nodes for the custom `featuredImgUrl` Frontmatter field.

As you may not want to require all blog posts to have a featured image, you can define some GraphQL types with Gatsby’s [Schema Customization API](https://www.gatsbyjs.org/docs/schema-customization/) to provide flexibility and control with your queries. Explicitly defining these types allows you to return `null` when a blog post does not contain a featured image in its frontmatter data. Even if there are no blog posts with these data fields, the type will still exist in the schema and can be used in your code.

```js
// gatsby-node.js
const { createRemoteFileNode } = require("gatsby-source-filesystem")

exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions

  createTypes(`
    type MarkdownRemark implements Node {
      frontmatter: Frontmatter
    }

    type Frontmatter {
      title: String!
      featuredImgUrl: String
      featuredImgAlt: String
    }
  `)
}

exports.onCreateNode = async ({
  node,
  actions: { createNode },
  store,
  cache,
  createNodeId,
}) => {
  // For all MarkdownRemark nodes that have a featured image url, call createRemoteFileNode
  if (
    node.internal.type === "MarkdownRemark" &&
    node.frontmatter.featuredImgUrl !== null
  ) {
    let fileNode = await createRemoteFileNode({
      url: node.frontmatter.featuredImgUrl, // string that points to the URL of the image
      parentNodeId: node.id, // id of the parent node of the fileNode you are going to create
      createNode, // helper function in gatsby-node to generate the node
      createNodeId, // helper function in gatsby-node to generate the node id
      cache, // Gatsby's cache
      store, // Gatsby's redux store
    })

    // if the file was created, attach the new node to the parent node
    if (fileNode) {
      node.featuredImg___NODE = fileNode.id
    }
  }
}
```

Going step by step through the code:

+ Define some types for `MarkdownRemark` using the Schema Customization API. Defining a field for alternative text as `featuredImgAlt` can also improve accessibility, in addition to providing context for the image if it fails to load.
+ Create an `onCreateNode` function so you can watch for when `MarkdownRemark` nodes are made.
+ Use `createRemoteFileNode` by passing in the various required fields and get a reference to the file afterwards.
+ If the Node is created, attach it as a child of the original Node. `___NODE` tells the GraphQL layer that the name before it is going to be a field on the parent Node that links to another Node. To do this, pass the `id` as the reference. Do note, this new node is now attached to the root of the `markdownRemark` node instead of the `frontmatter` field.

And since it is a File Node, `gatsby-transformer-sharp` will pick it up and create a `childImageSharp` child Node inside this newly created Node.

#### Usage in templates

Now that the images are being generated and available in GraphQL, you can use them in action.

If you open GraphiQL and write a query on the Markdown Nodes, you can see a new Node attached to any `MarkdownRemark` Node that had a featured image:

```graphql
query {
  allMarkdownRemark {
    nodes {
      featuredImg {
        childImageSharp {
          # ...
        }
      }
    }
  }
}
```

You can then use `gatsby-transformer-sharp` to fill in the query for a fixed image here. For more information on transforming images using parameters and fragments, check out the [Gatsby Image API docs](https://www.gatsbyjs.org/docs/gatsby-image/).

```graphql
query {
  allMarkdownRemark {
    nodes {
      featuredImg {
        childImageSharp {
          fixed(width: 600) {
            ...GatsbyImageSharpFixed
          }
        }
      }
    }
  }
}
```

And finally, you can update the template for this blog post to include a featured image node. Note the alt text still comes from the post frontmatter. This template is based on the one in the [Programmatically create pages from data](https://www.gatsbyjs.org/tutorial/part-seven/) section of the Gatsby Tutorial.

```jsx
import React from "react"
import Img from "gatsby-image"
import { graphql } from "gatsby"

const template = ({ data }) => {
  return (
    <>
      <h1>{data.markdownRemark.frontmatter.title}</h1>
      {data.markdownRemark.featuredImg && (
        <Img
          fixed={data.markdownRemark.featuredImg.childImageSharp.fixed}
          alt={data.markdownRemark.frontmatter.featuredImgAlt}
        />
      )}
      <div dangerouslySetInnerHTML={{ __html: data.markdownRemark.html }} />
    </>
  )
}

export default template

export const query = graphql`
  query BlogPostQuery($slug: String) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      frontmatter {
        title
        featuredImgAlt
      }
      html
      featuredImg {
        childImageSharp {
          fixed(width: 600) {
            ...GatsbyImageSharpFixed
          }
        }
      }
    }
  }
`
```
