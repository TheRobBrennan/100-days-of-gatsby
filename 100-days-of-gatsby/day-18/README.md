# Day 18 - Saturday, January 18th, 2020

Today's focus is on [Images, Files & Video in Gatsby](https://www.gatsbyjs.org/docs/images-and-files/)

## Scratchpad

To create a new Gatsby app, I will use `npx` to create a new [Gatsby](https://www.gatsbyjs.com) app using the latest version of the [Gatsby CLI](https://www.gatsbyjs.com):

```sh
# Generate a new app using the latest version of the Gatsby CLI
$ npx gatsby new app
  # OPTIONAL: Copy the Dockerized Gatsby CLI example to an appropriate folder for a faster starting point
  $ cp -r 100-days-of-gatsby/default-gatsby-cli-app-dockerized 100-days-of-gatsby/day-##

# Navigate to the appropriate example directory
$ cd 100-days-of-gatsby/day-##

# Navigate to the app directory
$ cd app
```

## Images, Files & Video in Gatsby

Gatsby provides multiple solutions for adding images, video, and files to your projects. And a pro tip: you don’t necessarily have to use GraphQL! From [imports](https://www.gatsbyjs.org/docs/importing-assets-into-files/) and use of the [static folder](https://www.gatsbyjs.org/docs/static-folder/) to dynamic queries with [Gatsby Image](https://www.gatsbyjs.org/docs/using-gatsby-image/) to prevent image bloat, you’ve got options.

This section will walk you through several common patterns for handling media with Gatsby, where you can learn about the pros and cons of each method.

### Importing Assets Directly into Files

#### Importing assets with Webpack

With Webpack you can import a file right in a JavaScript module. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This imported file’s value is the final path you can reference in your code, e.g. as the src attribute of an image or the href of a link to a PDF.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: svg, jpg, jpeg, png, gif, mp4, webm, wav, mp3, m4a, aac, and oga.

Here’s an example:

```jsx
import React from "react"
import logo from "./logo.png" // Tell Webpack this JS file uses this image

console.log(logo) // /logo.84287d09.png

function Header() {
  // Import result is the URL of your image
  return <img src={logo} alt="Logo" />
}

export default Header
```

This ensures that when the project is built, Webpack will correctly move the images into the public folder, and provide us with correct paths.

You can reference files in CSS to import them, too:

```css
.Logo {
  background-image: url(./logo.png);
}
```

Webpack finds all relative module references in CSS (they start with ./) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets.

If you’re using SCSS the imports are relative to the entry SCSS file.

Please be advised that this is also a custom feature of Webpack.

#### Querying for a File in GraphQL using gatsby-source-filesystem

You can also import files using GraphQL by querying for them in your data layer, which will trigger copying of those files to the public directory. Querying for the `publicURL` field of `File` nodes will provide URLs you can use in your JavaScript components, pages and templates.

##### Example: Copy all .pdf files you have in your data layer to your build directory and return URLs to them:

```graphql
{
  allFile(filter: { extension: { eq: "pdf" } }) {
    edges {
      node {
        publicURL
      }
    }
  }
}
```

Reference those PDF files in a page with useStaticQuery:

```jsx
import React from "react"
import { useStaticQuery, graphql } from "gatsby"

import Layout from "../components/layout"

const DownloadsPage = () => {
  const data = useStaticQuery(graphql`
    {
      allFile(filter: { extension: { eq: "pdf" } }) {
        edges {
          node {
            publicURL
            name
          }
        }
      }
    }
  `)
  return (
    <Layout>
      <h1>All PDF Downloads</h1>
      <ul>
        {data.allFile.edges.map((file, index) => {
          return (
            <li key={`pdf-${index}`}>
              <a href={file.node.publicURL} download>
                {file.node.name}
              </a>
            </li>
          )
        })}
      </ul>
    </Layout>
  )
}
export default DownloadsPage
```

##### Example: Link to attachments in the frontmatter of your Markdown files:

```md
---
title: "Title of article"
attachments:
  - "./assets.zip"
  - "./presentation.pdf"
---

Hi, this is a great article.
```

In an article template component file, you can then query for the attachments:

```graphql
query($slug: String!) {
  markdownRemark(fields: { slug: { eq: $slug } }) {
    html
    frontmatter {
      title
      attachments {
        publicURL
      }
    }
  }
}
```

### Using the Static Folder

In general, every website needs assets: images, stylesheets, scripts, etc. When using Gatsby, we recommend Importing Assets Directly in JavaScript files, because of the benefits it provides:

+ Scripts and stylesheets are minified and bundled together to avoid extra network requests.
+ Missing files cause compilation errors instead of 404 errors for your users.
+ Result filenames include content hashes so you don’t need to worry about browsers caching their old versions.

However, there is an escape hatch that you can use to add an asset outside of the module system.

#### Adding assets outside of the module system

You can create a folder named static at the root of your project. Every file you put into that folder will be copied into the public folder. E.g. if you add a file named `sun.jpg` to the static folder, it’ll be copied to `public/sun.jpg`

##### Referencing your static asset

You can reference assets from the static folder in your code without anything special required:

```jsx
render() {
  // Note: this is an escape hatch and should be used sparingly!
  // Normally we recommend using `import` for getting asset URLs
  // as described in the “Importing Assets Directly Into Files” page.
  return <img src={'/logo.png'} alt="Logo" />;
}
```

##### Downsides

Keep in mind the downsides of this approach:

+ None of the files in the `static` folder will be post-processed or minified.
+ Missing files will not be called at compilation time, and will cause 404 errors for your users.
+ Result filenames won’t include content hashes, so you’ll need to add query arguments or rename them every time they change.

#### When to use the static folder

Normally we recommend importing stylesheets, images, and font assets from JavaScript. The static folder is useful as a workaround for a number of less common cases:

+ You need a file with a specific name in the build output, such as manifest.webmanifest.
+ You have thousands of images and need to dynamically reference their paths.
+ You want to include a small script like pace.js outside of the bundled code.
+ Some libraries may be incompatible with Webpack and you have no other option but to include it as a <script> tag.
+ You need to import JSON file that doesn’t have a consistent schema, like TopoJSON files, which is difficult to handle with GraphQL. Note that importing JSON files directly inside a page, a template, or a component using import syntax results in adding that file to the app bundle and increasing the size of all site’s pages. Instead, it’s better to place your JSON file inside the static folder and use the dynamic import syntax (import('/static/myjson.json')) within the componentDidMount lifecycle or the useEffect hook.

### Using gatsby-image

`gatsby-image` is a React component designed to work seamlessly with Gatsby’s GraphQL queries (gatsby-image plugin README). It combines Gatsby’s native image processing capabilities with advanced image loading techniques to easily and completely optimize image loading for your sites. `gatsby-image` uses `gatsby-plugin-sharp` to power its image transformations.

Warning: `gatsby-image` is not a drop-in replacement for `<img />`. It’s optimized for fixed width/height images and images that stretch the full width of a container. Some ways you can use `<img />` won’t work with `gatsby-image`.

`gatsby-image` includes the tricks you’d expect from a modern image component. It:

+ uses the new [IntersectionObserver API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) to cheaply lazy load images
+ holds an image’s position so your page doesn’t jump around as images load
+ makes it easy to add a placeholder—either a gray background or a blurry version of the image.

For more complete API information, check out the [Gatsby Image API](https://www.gatsbyjs.org/docs/gatsby-image/) docs.

#### Problem

Large, unoptimized images dramatically slow down your site.

But creating optimized images for websites has long been a thorny problem. Ideally, you would:

+ Resize large images to the size needed by your design
+ Generate multiple smaller images so smartphones and tablets don’t download desktop-sized images
+ Strip all unnecessary metadata and optimize JPEG and PNG compression
+ Efficiently lazy load images to speed initial page load and save bandwidth
+ Use the “blur-up” technique or a “traced placeholder” SVG to show a preview of the image while it loads
+ Hold the image position so your page doesn’t jump while the images load
+ Doing this consistently across a site feels like Sisyphean labor. You manually optimize your images and then… several images are swapped in at the last minute or a design-tweak shaves 100px of width off your images.

Most solutions involve a lot of manual labor and bookkeeping to ensure every image is optimized.

This isn’t ideal. Optimized images should be easy and the default.

#### Solution

With Gatsby, you can make the experience of working with images way, way better.

`gatsby-image` is designed to work seamlessly with Gatsby’s native image processing capabilities powered by GraphQL and Sharp. To produce perfect images with minimal effort, you can:

+ Install `gatsby-image` and other, necessary dependencies like `gatsby-plugin-sharp` and `gatsby-transformer-sharp`
+ Add the newly installed plugins and transformer plugins to your `gatsby-config.js`
+ Configure `gatsby-source-filesystem` to load images from a folder. In order to use GraphQL to query the image files, the files need to be in a location that is known to Gatsby. This requires an update to `gatsby-config.js` to configure the plugin. Feel free to replace the path option to reference wherever your images are located in your project.
+ Write a GraphQL query using one of the included GraphQL “fragments” which specify the fields needed by `gatsby-image` to create a responsive, optimized image. This example queries for an image at a path relative to the location specified in the `gatsby-source-filesystem` options using the `GatsbyImageSharpFluid` fragment. This GraphQL query creates multiple sizes of the image and when the page is rendered the image that is appropriate for the current screen resolution (e.g. desktop, mobile, and everything in between) is used. The gatsby-image component automatically enables a blur-up effect as well as lazy loading images that are not currently on screen.
+ Import `Img` to display the fragment in JSX. There are additional features available with the `Img` tag as well, such as the `alt` attribute for accessibility.

### Working with Images in Gatsby

Optimizing images is a challenge on any website. To utilize best practices for performance across devices, you need multiple sizes and resolutions of each image. Luckily, Gatsby has several useful [plugins](https://www.gatsbyjs.org/docs/plugins/) that work together to do that for images on [page components](https://www.gatsbyjs.org/docs/building-with-components/#page-components).

The recommended approach is to use [GraphQL queries](https://www.gatsbyjs.org/docs/querying-with-graphql/) to get images of the optimal size or resolution, then, display them with the `gatsby-image` component.

#### Query images with GraphQL

Querying images with GraphQL allows you to access the image’s data as well as perform transformations with [Sharp](https://github.com/lovell/sharp), a high-performance image processing library.

You’ll need a few plugins for this:

+ `gatsby-source-filesystem` plugin allows you to query files with GraphQL
+ `gatsby-plugin-sharp` powers the connections between Sharp and Gatsby Plugins
+ `gatsby-transformer-sharp` allows you to create multiples images of the right sizes and resolutions with a query

If the final image is of a fixed size, optimization relies on having multiple resolutions of the image. If it is responsive, that is it stretches to fill a container or page, optimization relies on having different sizes of the same image. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for more information.

You can also use arguments in your query to specify exact, minimum, and maximum dimensions. See the [Gatsby Image documentation](https://www.gatsbyjs.org/packages/gatsby-image/#two-types-of-responsive-images) for complete options.

#### Optimizing images with gatsby-image

`gatsby-image` is a plugin that automatically creates React components for optimized images that:

+ Loads the optimal size of image for each device size and screen resolution
+ Holds the image position while loading so your page doesn’t jump around as images load
+ Uses the “blur-up” effect i.e. it loads a tiny version of the image to show while the full image is loading
+ Alternatively provides a “traced placeholder” SVG of the image
+ Lazy loads images, which reduces bandwidth and speeds the initial load time
+ Uses WebP images, if browser supports the format

#### Using fragments to standardize formatting

What if you have a bunch of images and you want them all to use the same formatting?

A custom fragment is an easy way to standardize formatting and re-use it on multiple images:

```js
export const squareImage = graphql`
  fragment squareImage on File {
    childImageSharp {
      fluid(maxWidth: 200, maxHeight: 200) {
        ...GatsbyImageSharpFluid
      }
    }
  }
`
```

The fragment can then be referenced in the image query:

```js
export const query = graphql`
  query {
    image1: file(relativePath: { eq: "images/image1.jpg" }) {
      ...squareImage
    }

    image2: file(relativePath: { eq: "images/image2.jpg" }) {
      ...squareImage
    }

    image3: file(relativePath: { eq: "images/image3.jpg" }) {
      ...squareImage
    }
  }
`
```

### Preoptimizing Your Images

### Working with Video

### Importing Media Content

### Working with GIFs

### Working with Images in Markdown

### Preprocessing External Images
